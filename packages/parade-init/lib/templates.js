/**
 * Project Template Generator
 *
 * Generates starter configuration files for Parade projects.
 * Implementation for task customTaskTracker-ym7.4
 */

const fs = require('fs').promises;
const path = require('path');

/**
 * Stack-specific defaults for project.yaml
 */
const STACK_DEFAULTS = {
  frontend: {
    test_command: 'npm test',
    build_command: 'npm run build',
    lint_command: 'npm run lint',
    suggested_frameworks: ['react', 'vue', 'angular', 'svelte', 'nextjs'],
    suggested_languages: ['typescript', 'javascript']
  },
  backend: {
    test_command: 'npm test',
    build_command: 'npm run build',
    lint_command: 'npm run lint',
    suggested_frameworks: ['express', 'fastify', 'nestjs', 'hono', 'django', 'fastapi', 'rails'],
    suggested_languages: ['typescript', 'javascript', 'python', 'ruby', 'go']
  },
  mobile: {
    test_command: 'npm test',
    build_command: 'npm run build',
    lint_command: 'npm run lint',
    suggested_frameworks: ['react-native', 'expo', 'flutter', 'swiftui'],
    suggested_languages: ['typescript', 'javascript', 'dart', 'swift', 'kotlin']
  },
  database: {
    test_command: 'npm test',
    build_command: '',
    lint_command: '',
    suggested_frameworks: ['prisma', 'drizzle', 'typeorm', 'knex', 'sqlalchemy'],
    suggested_languages: ['sql', 'typescript', 'python']
  }
};

/**
 * Generate project.yaml content from options
 * @param {object} options - Configuration options
 * @param {string} options.projectName - Project name (required)
 * @param {string} options.projectDescription - Project description (optional)
 * @param {string} options.stackType - Stack type: 'frontend', 'backend', 'mobile', 'database' (optional)
 * @param {string} options.framework - Framework name (optional)
 * @param {string} options.language - Programming language (optional)
 * @returns {string} YAML content
 */
function generateProjectYaml(options = {}) {
  if (!options.projectName) {
    throw new Error('projectName is required');
  }

  const projectName = options.projectName;
  const projectDescription = options.projectDescription || `${projectName} project`;
  const stackType = options.stackType || null;
  const framework = options.framework || null;
  const language = options.language || 'typescript';

  // Get stack-specific defaults
  const stackConfig = stackType ? STACK_DEFAULTS[stackType] : STACK_DEFAULTS.frontend;

  // Build YAML content
  const lines = [];

  // Header comment
  lines.push('# Project Configuration for Parade Workflow Orchestrator');
  lines.push('# Generated by parade-init');
  lines.push('');

  // Project section
  lines.push('project:');
  lines.push(`  name: ${projectName}`);
  lines.push(`  description: ${projectDescription}`);
  lines.push('');

  // Stack section
  lines.push('stack:');
  if (stackType) {
    lines.push(`  type: ${stackType}`);
  }
  lines.push(`  language: ${language}`);
  if (framework) {
    lines.push(`  framework: ${framework}`);
  }
  lines.push('');

  // Commands section
  lines.push('commands:');
  if (stackConfig.test_command) {
    lines.push(`  test: ${stackConfig.test_command}`);
  }
  if (stackConfig.build_command) {
    lines.push(`  build: ${stackConfig.build_command}`);
  }
  if (stackConfig.lint_command) {
    lines.push(`  lint: ${stackConfig.lint_command}`);
  }
  lines.push('');

  // Conventions section
  lines.push('conventions:');
  lines.push('  naming:');
  lines.push('    files: kebab-case');
  lines.push('    variables: camelCase');
  lines.push('    constants: SCREAMING_SNAKE_CASE');
  lines.push('  code_style:');
  lines.push('    max_line_length: 100');
  lines.push('    indent: 2');
  lines.push('');

  // Paths section
  lines.push('paths:');
  lines.push('  source: src/');
  lines.push('  tests: tests/');
  lines.push('  docs: docs/');
  lines.push('');

  // Agent preferences section
  lines.push('agent_preferences:');
  lines.push('  default_model: sonnet');
  lines.push('  review_model: sonnet');
  lines.push('  complex_model: opus');
  lines.push('');

  return lines.join('\n');
}

/**
 * Write project.yaml to disk, backing up existing file if present
 * @param {string} projectPath - Project root path
 * @param {object} options - Configuration options (same as generateProjectYaml)
 * @returns {Promise<{written: boolean, backedUp: boolean, path: string}>}
 */
async function writeProjectYaml(projectPath, options = {}) {
  const yamlPath = path.join(projectPath, 'project.yaml');
  const backupPath = path.join(projectPath, 'project.yaml.bak');

  try {
    // Generate YAML content
    const yamlContent = generateProjectYaml(options);

    // Check if file already exists
    let backedUp = false;
    try {
      await fs.access(yamlPath);
      // File exists, create backup
      await fs.copyFile(yamlPath, backupPath);
      backedUp = true;
      console.log(`  Backed up existing project.yaml to project.yaml.bak`);
    } catch {
      // File doesn't exist, no backup needed
    }

    // Write the new file
    await fs.writeFile(yamlPath, yamlContent, 'utf8');

    return { written: true, backedUp, path: yamlPath };
  } catch (error) {
    throw new Error(`Failed to write project.yaml: ${error.message}`);
  }
}

/**
 * Get available stack types and their configurations
 * @returns {object} Stack defaults configuration
 */
function getStackDefaults() {
  return { ...STACK_DEFAULTS };
}

/**
 * Validate stack type
 * @param {string} stackType - Stack type to validate
 * @returns {boolean} True if valid
 */
function isValidStackType(stackType) {
  return Object.keys(STACK_DEFAULTS).includes(stackType);
}

module.exports = {
  generateProjectYaml,
  writeProjectYaml,
  getStackDefaults,
  isValidStackType,
  STACK_DEFAULTS
};
